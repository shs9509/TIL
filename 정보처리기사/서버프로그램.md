-----------

### 정렬

3가지 정렬 문제가 나오고 이를 자바, 파이썬, C 로 다 적진 못해도 핵심부분은 쓸 수 있어야한다.

- 버블 정렬

  앞수와 비교를 해서 자리를 바꾸는 방식

  ```
  82913 > 28139 > 21389 > 12389 끝
  ```

  

  - JAVA

  ```java
  //82913 > 28139 > 21389 > 12389 끝
  
  for(int i=0; i<len(a); i++){
      for(int j=0; j<len(a)-i; j++){ //끝자리부터 채워지기 때문에 4-i
          if(a[j]>a[j+1]){
              tmp = a[j];
              a[j] = a[j+1];
              a[j+1] = tmp
          }
      }
}
  ```
  
  간단한 정렬이기떄문에 전후 비교를 계속해서 한번의 정렬 결과 맨뒤에가 채워진다는 것을 알면된것이다.



- 선택 정렬

  정렬 안된 수 중 작은(큰) 값을 찾아내서 해당위치와 바꾸는 방식 

  ```
  829(1)3 > 1(2)983 > 1298(3) > 123(8)9 > 1238(9) 끝
  ```

  

  - JAVA

  ```java
  //829(1)3 > 1(2)983 > 1298(3) > 123(8)9 > 1238(9) 끝
  
  for(int i=0 ; i<n-1 ; i++){
      int min_Val = i; // i를 일단 최소자리값으로 저장
      
      for(int j=i+1 ; j<n ; j++){	// 다음수부터 순회를 돌아서(앞자리부터 쌓이기때문) 
          if(a[j]< a[min_val]){ // 최소값을 찾으면 
              min_val = j;	// 그자리를 최소자리로 설정
          }
      }
      if(min_val != i){	// 최소자리가 원래i가 아니면 변경해야한다.
          int tmp = a[i];
          a[i] = a[min_val];
          a[min_val] = tmp;
      }
  }
  ```

  여기서 알아야하는 것은 **"최소값"**을 미리 구하려고 한다는것

  뒷부분이 버블정렬과 비슷한데 헷갈리지 말것

  

- 삽입 정렬

  하나의 수를 택해서 다음수와 비교를하며 비교가 멈출때 까지 **"쉬프트"** 하는 방식

  ```
  8(2)913 > 28(9)13 > 289(1)3 > 1289(3) > 12389 끝
  ```

  

  - JAVA

  ```java
  //8(2)913 > 28(9)13 > 289(1)3 > 1289(3) > 12389 끝
  
  // 오름차순
  for(int i=1 ; i < n ; i++){
      int key =a[i];	// 비교할 자리 1부터 시작
      int j =i - 1	// i가 3이면 2,1,0순으로 비교할수있게 한다.
      while(j>=0 && a[j]>key){ // while문 돌리기
          a[j+1] = a[j];	//a[j]가 더 크다면 a[j]를 키가있던 j+1 자리에 위치시킨다.
          j--;	// 비교위치 j는 한칸 앞으로와서 비교
      }
      a[j+1] = key; //비교가 끝나면 키의값을 j+1 위치에 놓아준다.
}
  ```

  여기서 유심히 봐야하는건 

  - `a[j+1] = a[j];`
  
  - `a[j+1] = key;` 


