### 교착상태

- 예방기법 - 상호배제, 점와대기, 비선점 및 환형대기 조건의 부정
- 회피기법 - 뱅커스알고리즘(자원할당하면 안정상태인지 확인하는 방법), wait-die,wound-wait 알고리즘
- 발견기법 - 감시알고리즘, 자원할당그래프, wait for 그래픔
- 회복기법 - 하나의 kill하는방법



세마포어 - 상호배제알고리즘

P연산 자원할당 s= s-1

S연산 자원해제 s= s+1



### LRU

- 가장 오래된거 교체
- LFU - 사용빈도가 가장 적은거
- NUR - 최근에 사용되지 않은 페이지
- 최적페이지 - 앞으로 가장오래 쓰지않을 페이지



UNIX - i node

디스크 스켸줄링

- 이동디스크 - FCFS(큐에따라), SSTF(헤드위치에 가까운거), SCAN( 진행방향에 가까운거), LOOK, 에센바흐 
- 고정디스크
  - S(shortest)L(latency)T(time)F(first)(최단 지연시간) 
  - SP(positioning)TF(최단위치시간) 
  - SA(accessing)TF(최단 접근시간)



FIFO +RR =>멀티레벨피드백 q 

RR 없으면 => 멀티레벨큐



HRN

우선순위 = 대기시간 + 서비스시간 / 서비스시간

SJF 

- shortest job first

위에는 비선점스켸쥴링으로 작업도중 우선순위를 따지지않는다.

선점스켸쥴링은 중간에 멈추고 딴거함



가상메모리

보조기억장치를 주기억장치처럼사용할수있게 메모리를 확장하는 것

배치정잭으로

- worst fit , best fit , first fit

할당정책

- 고정할당, 가변할당

교체정책

- LRU FIFO LFU NUR

호출정책

- 요구호출 , 예측호출



메모리 인터리빙 기법

- 기억모듈에 중복적인 데이터 접근을 방지하기위해 연속된데이터 명령어를 순차적으로 처리하는 기법

구역성

- 프로그램의 한부분만 집중적으로 참조하는 현상

세그멘테이션 기법

- 가상기억장치에 프로그램,데이터를 저장할때 가변의 세그먼트로 분할

페이징 기법

- 고정단위

링커

독립적인 목적프로그램을 연계시켜준다.



로더

프로그램을 주기억장치에 적재

할당 링킹 재배치 로딩



Flynn의 컴퓨터시스템 분류

명령어/데이터 흐름

SIMD SISD MIMS MIMD



분산처리시스템

클라이언트/서버 모델(비대칭)

프로세서 풀 모델 (워크스테이선 -서버 모델로 구성)

혼합모델



데이터베이스 - 내부 ,외부, 개념 단계

RDBMS / NOSQL



NOSQL의 데이터 저장구조

key / value

ordered key / value

document key / value 



논리적 데이터 독립성/ 물리적 데이터 독립성



릴레이션 스키마, 릴레이션 인스턴스, 카디널리티, 튜플, ()속성의 도메인

레코드 - 릴레이션의 각행 = 튜플

릴레이션  -테이블

에트리뷰트 - 속성한줄

도메인 - 한속성에 있는 값들

차수 -에트리뷰트의 수

카디널리티 - 튜플, 레코드의 수



후보키, 기본키, 대체키(기본키제외 떨거지), 슈퍼키(최소성 만족x), 외래키 



데이터와 실제와 정확히 일치하는것을 '무결성' 이라고 한다.

무결성 보장하는 언어 (DCL) ->commit  rollback  savepoint



관계대수 - 원하는 정보가 뭔지, 어떻게 검색해서 정보를유도할것인지 까지 있는 절자적인 언어

관계해석 - 원하는 정보가 뭔지만 나타내는 비절차적인 언어



트랜잭션

데이터베이스의 상태를 변화시키기위해 수행하는 작업의 단위

- ''원자성''  : 쪼갤질수없음 트루올 폴스
- ''일관성''  : 일관성있게 db 에 저장
- ''고립성''  : 다른 트랙잭션이 접근할수없다.
- ''영속성''  : 저장되면 DB 에 영구적으로 저장되있는다.

데이터 베이스 장애

- 트랜잭션 장애 - 트랜잭션하는 데이터가 이상
- 시스템 장애 - 하드웨어나 정전같은 문제
- 디스크 장애 - 디스크 블록의 손상 , 데이터가 물리적으로 손상된 경우
- 사용자 장애 - 사용자의 실수



데이터베이스 회복

회복 구성요소 - UNDO(수행중인 데이터를 회복) REDO(이미 완료된 데이터를 회복)

- 지연갱신 - 트랙잭션이 제대로 끝날떄 까지 db 갱신을 미룸
- 즉시갱신 - 그냥 바로 실제 데이터를 기입하는 방법
- 그림자페이지 - 갱신이전의 데이터를 복사본인 그림자 페이지로 보관하고 나중에 변경작업에 쓰임
- 검사점 - 검사점이후로 트랜잭션이 완료되면 REDO 완료되지 않았다면 UNDO를 실행
- 미디어회복 - 디스크의 최근 덤프내용을 디스크에 적재하여 완료된 트랜잭선에 REDO



병행제어

- 다중 사용자환경에서 여러 트랜잭션이 동시에 일어날수있도록, 동시성 제어라고도 한다.

-> 일관성을 보장하는 것을 직렬성 (다중 환경에서)

안하면?

- 갱신내용 손실 - 동시에 [데이터를 갱신]할때 덮어쓰여짐 (READ 안에 변경 변경)
- 오류데이터 읽기 - 중간결과를 다른 곳에서 읽음
- 모순성  - 동시에 DB를 액세스함 [트랜잭션]해서 값이다름! (READ 변경, READ 변경)
- 연쇄복귀 혹은 회복불능 - 실패해서 롤백하려고하나 다른 완료된 트랙잭션떄문에 실행 불가

방법은?

- 로킹 : 트랜잭션에 사용하는 데이터를 다른 곳에서 접근하지 못하게 락을 걸어놓는것
- 검증기법 : 복사본에 대해서 미리 트랙잭션을 진행해보고 이상이없으면 진행 
- 타임스탬프기법 : 트랙잭션의 도착 순서대로 타임스탬프를 할당해서 그 순서로 트랜잭션 우선권을 가진다.