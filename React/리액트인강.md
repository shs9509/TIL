## 바벨

리액트에서는 JSX 문법을 createElement 함수를 호출하는 하는코드로 변환하기위해서

주석제거



원래라면 리액트에서 createElement로 구성을해야지 만들어짐

근데 JSX라는 편한 방법이 있음 근데 이거를 바벨을 쓰면

JSX -> createElement로 만들어줌



npm 패키지를 관리하려면 package.json이 필요함

```bash
npm init -y
npm install @babel/core @babel/cli @babel/preset-react
```

1.  바벨 핵심기능

2. cli 쓸 바이너리

3. 리액트를 쓰기위한 플러그인



플러그인 : 변환하는 기능 을 모아놓은걸 -> 프리셋인라고함

```bash
npx babel --watch src --out-dir . --presets @babel/preset-react
바뀔떄마다(watch) 컴파일 src에 있는걸 현재로꺼냄(.) 그리고 프리셋으로 바벨설치한거 사용함 
```

npx 는 바벨 바이너리를 실행해줌 없으면 설치해서 실행해줌



바벨 실행하면 createElement 로 바뀜



## 웹팩

- 파일내용 기반으로 파일 이름에 해시값추가 -> 효율적인 브라우저 캐싱이용
  - etag를 이요했을때 서버한테 이캐시를 사용해도되는지 물어봄
  - 근데 파일에 해시키가 있다? 서버한테 안물어봐도됨

- 자스 압축
- 사용되지않는 코드 제거
- 가장큰이유
  - 모듈시스템을 사용하고 싶어서
  - ESM commonJS



자스파일이 많아지면서 필요성 높아짐

글로벌 변수라든가  파일순서에 따라 큰일남

제이쿼리같은거 외부라이러리 쓰면 cdn 써야되는데 문제있으면 다 문제

우리cdn을 쓸수도있는데 그경우에는 파일이름의 싱크가 맞아야됨 또관리해야됨

 

웹팩쓰면해결

변수는 빌드단계에서 잡아님

외부라이브러리 npm

번들링단계에서 다합쳐짐



요즘 브라우저는 ESM을 지원하지만 오래된브라우저는 ㄴㄴ

많은 오픈소스가 commonJS로 작성되기 떄문에 결국 웹팩을 써야함



npm webpack webpack-cli

npx webpack

이러면 모든파일이 하나로 합쳐짐



## create-react-app

빌드시스템을 위해서 웹팩이나 바벨을 깔아야됨

테스트환경은 제스트

eslint, 폴리필, HMR(코드변경하면 바로나타내주는거),  등등 다 자동으로 구축해서 제공해줌

페이스북에서 관리함

 

next.js 와 차이는 서버사이드 렌더링 지원여부 cra는 지원x!!!!!!!! 
단점은 빌드시스템이나eslint등의 설정을 거의 변경할수없다는점 넥스트는 설정변경가능함

쉽고빠른점이 굳, 특히 백오피스



cra가 버전업되면 대부분 react-scripts가 업글된다고보면됨



npm start 는 개발모드에서만

성능최적화가 안되어있음

배포할때는 반드시 빌드명령어



PWA



strictMode는 리액트에서 잘못된거 잡아낼때 씀

이미지는 import해서 쓸수있는데 이게좋은게 해시값이 들어가서 브라우저 캐싱을 효율적으로함

동적으로 데이터 불러오기

```js
import('./data.json').then(({default:data})=> {
    console.log({data});
})
                           }
```



### 명령어

```reac
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
```



```ba
npx serve -s build
```

```
HTTPS= true npm start
```



빌드를하면 작은이미지는 js에 내장되고 =>http요청횟수를 줄이기위함 근데 2.0되면서 의미이없음

큰파일은 따로 생서이된다.





### test

`__test__`파일 만들고 안에 넣는 파일은 모두다 테스트파일이된다.

`.test.js`이렇게 관리하면 비슷한 파일과 가까이있어서 편함



## 폴리필

core-js를 많이 사용함

원하는 걸 찾아내서 index.js에 import 시키자 

cra는 이미 core-js 가 내장되어있기 때문에 임포트만 하면됨



## 환경변수

process.env.(변수이름)

process.env.NODE_ENV

- npm start = > development

- npm test => test

- npm run build =>production

REACT_APP_() -> 환경변수를 커맨드라인에서 출력가능

process.env.REACT_APP_()

환경변수파일이 많아지면 `.env`파일에 넣어서 관리하자





## CSS

- 일반적인 CSS파일

  - 그냥 className줘서 css파일 임포트해서 쓰는거임
  - 빌드가되면 이름이 충돌되서 안된다.

- css-module

  - css파일이름이 일단 `.module.css`로 이름이 끝남

  - 임포트하면 객체형식으로 보낸다.

  - 클래스명을 속성이름으로 입력하면됨

  - ```js
    <div className ={`${Style.button} ${Style.big}`}><div/>
    ```

  - 값을보면 해시값이 붙어서 나오기때문에 이름충돌이 없다.

  - classnames를 사용하면 편하게사용가능

    - ```js
      import cn from 'classnames'
      <div className ={cn(Style.button, Style.big)}><div/>
      ```

    - `cn`을 활용하면 조건부 css적용도 가능하다.

- Sass로 작성하기

  - ```
    npm install node-sass
    ```

  - css파일이름은 `.scss`

  - css에서 정의한 변수를 임포트해서 재사용이 가능하다.

- css-in-js로 작성하기

  - js안에서 씀

  - 재사용가능 동적으로 작성가능

  - 둘다하면 쓰면좋은 따로 쓰면 별로

  - ```
    npm install styled-components
    ```

  - ```js
    import styled from 'styled-components';
    const Box = styled.div`
    	height: 50px;
    	background-clor: #000;
    `;
    const BigBox = styled.{Box}`
    	width:100%
    `;
    
    const SmallBox = styled.{Box}`
    	width: ${Props=>(props.isBig ? 100:300)}px;
    `;
    ```

  - `Box`를 변수취급을해서 확장이 가능하다.

  - 동적으로 처리도 가능하다.





## SPA

- SPA 조건
  - 브라우저가 서버로 요청하지않는다는 가정하에
  - JS에서 브라우저로 페이지전환 요청을 보냄, + 뒤로가기
  - 이걸만족해주는 브라우저 API
    - pushState, replaceState (JS에서 브라우저에게 페이지전환이벤트를 알려줌)
    - popstate (브라우저에서 JS)



- react-router-dom

  - 코드분할기능
    - 안하면 한JS에 모든코드가 모이기되서 렌더링에 오래걸린다.
    - 쓰는 페이지별로 코드분할이 가능하다.

  ```
  npm install react-router-dom
  ```

  - `BrowserRouter`에서 현재페이지의 상태값을 관리함

  - `Link`는 `to`에 맞는 링크로 이동

  - `Route`는 어떤컴포넌트로 렌더링할지 결정해줌

    - `path`에서 `exaxt`는 정확한 이름을 정할때 사용 =>유용하게쓰임

    - `path`를 따라가면 해당 페이지에서는 `match`로 받는다.

      - 사용법으로는 이후 링크가 다른페이지로 이어진다면

      - ```react
        <Route path={`${match.url}/detail`} component={Movie}/>
        <Route path={`${match.url}:id`} component={Movie}/>
        ```

      - `:` 는 파라미터 => `match.params.id`로 받으면 됨







  

- UI코드와 비즈니스로직이 나눠진다는 점에서 상당한 이득이있다.



## 상태값과 속성값

값이 변경된걸 보여주려면 상태값을 관리를 해야함  `useState`



```react
export default function Title(props){
    return <p>{props.title></p>
}
```

```react
export default function Title({title}){
    return <p>{title></p>
}
```



```react
export default React.memo(Title);
```

메모를 쓰면 해당값만 바뀌 경우에만 렌더링이 취해짐



- 컴포넌트
  - 같은 컴포넌트가 다수일지라 하더라고 각자 공간에서 각자의 값을 갖고있음 	
  - 공유하지않는다.



- 전개연산자를 활용해서 객체를 불변변수로 관리를 한다.

  - ```react
    const [count, setCount] = {value:0,value1:0,value2:0,value3:0};
    function onClick(){
        setCount({...count, value:count.value+1});
    }
    ```

    

## 함수의 반환값

- 함수, 문자, 컴포넌트, 배열 다반환가능

`fragment`라는 것도 반환이 가능함 이건 여러개의 요소를 반환할때 사용함

```react
return (
	<React.Fragment>
		<p>'안녕'</p>
        <p>'하세요'</p>
	</React.Fragment>
);
```

이때 키값이 필요없는 이유는 순서가 키값으로 반영되기 때문

원래는 `div`태그를 이용해야했는데 이거는 원치않는데도 태그가 추가된다는 단점이 존재.

아래꺼는 똑같은거임 축약형

```react
return (
	<>
		<p>'안녕'</p>
        <p>'하세요'</p>
	</>
);
```



- 조건부렌더링도 가능함

- 리액트 Portal도 반환가능함

  ```react
  import ReactDOM from 'react-dom'
  return (
  	<>
      	{REACTDOM.createProtal(
           	<div>
           		<p>넣는요소</p>
           	</div>,
           	document.getElementById('something'),
           )}
      </>
      
  )
  ```

  첫번쨰 인자는 넣을꺼 ,두번쨰는 넣는 장소

  - 보통 모달을 이용하는데 많이 사용함