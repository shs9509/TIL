# 하둡



요즘은 병렬 분산 알고리즘을 디자인해서 빅데이터를 처리해야함

- 그런데
  - 로우엔드 머신 대량 스케일 아웃방식 > 하이엔드 머신 스케일 업 방식
- 그래서
  - 데이터 중심 애플리케이션에서 많은 컴퓨터를 묶어서 처리하기 쉽게 만들어주는 맵리듀스 프레임워크가 많이 사용됨

- 구글의 맵리듀스, 하둡은 데이터 애플리케이션을 만드는데 효율적인 툴임



## 맵리듀스

- 맵리듀스
  - 빅데이터를 처리하는 스케일러블 병렬 애플리케이션 개발을 도와주는 프로그래밍 모델
  - 맵리듀스 프레임 워크
    - HDFS라는 분산파일 시스템이 빅데이터를 여러 머신에 분산하여 저장
    - 파일을 블록으로 나누어서 저장하고 여러개로 복사되어서 저장된다.
      - 결함에도 정상 작동을 위해서

- 각 맵함수와 리듀스의 출력
  - 각각의 레코드 튜플이 key, value 쌍으로 나타남



- 맵리듀스 페이즈
  - 맵-페이즈
    - 유저가 정의한 맵함수가 데이터의 여러 파티션에 병렬 분산으로 호출되고 수행
    - 맵함수에서 출력한 결과들이 key,value 쌍으로 표현되서 
    - 여러 머신에 key에 따라 랜덤하게 전달됨

  - 셔플링-페이즈
    - 각 머신에 모인 key,value 들을 key를 통해 정렬하고 
    - 키마다 value들을 병합하려 리스트를 만듬

  - 리듀스-페이즈
    - key, value 리스트 마다 한개의 리듀스 함수가 호출되고 수행됨
    - 출력이 있으면 key,value 형태로 출력됨
    - 

- 구성
  - 마스터 역할인 한개의 네임노드
    - 수행 전 전처리를 하거나 리듀스 함수의 결과를 후처리함
    - 파일 시스템을 관리하고 클라이언트 파일에 접근할수있게 함
  - 슬레이브 역할인 여러 개의 데이터 노드
    - 컴퓨터에 있는 데이터에 접근할 수 있게 함



맵리듀스 프레임 워크의 주요 구성 요소

- 맵리듀스
  - 소프트웨어의 수행을 분산하는 역할
- Hadoop 분산파일 시스템
  - 데이터를 분산하는 역할





## 하둡

- 하둡은 여러개의 컴퓨터를 하나로 묶어서 대용량으로 처리하는 기술

- 대용량 파일을 저장 기능인 분산파일 시스템과 분산파일을 빠르게 분석하는 맵 리듀스 플랫폼으로 구성되어있음



### 1. 하둡이란?

하둡은 2006년 야후의 더그 커팅이 '넛치'라는 검색엔진을 개발하는 과정에서
대용량의 비정형 데이터를 기존의 RDB 기술로는 처리가 힘들다는 것을 깨닫고,
새로운 기술을 찾는 중 GFS(Google File System)와 MapReduce 관련 논문을 참고하여 개발하였습니다.
이후 아파치 재단의 오픈 소스로 공개 되었습니다.

하둡은 하나의 성능 좋은 컴퓨터를 이용하여 데이터를 처리하는 대신
적당한 성능의 범용 컴퓨터 여러 대를 클러스터화하고, 큰 크기의 데이터를 클러스터에서 병렬로 동시에 처리하여 처리 속도를 높이는 것을 목적으로 하는 분산처리를 위한 오픈소스 프레임워크라고 할 수 있습니다.

하둡은 분산시스템인 `HDFS(Hadoop Distributed File System)`에 데이터를 저장하고, 맵리듀스를 이용해 데이터를 처리한다.

마존, 마이크로소프트, IBM, 오라클 VM웨어, 테라데이터들이 적극 사용하면서 하둡의 환경이 확장되었다.

이젠 빅데이터 처리와 분석을 위한 플랫폼중 사실상 표준이다.



### HDFS

HDFS는 `Hadoop Distributed File System`의 약자이다.
수십 테라바이트 또는 페타바이트 이상의 대용량 파일을 분산된 서버에 저장하고, 그 저장된 데이터를 빠르게 처리할 수 있게 하는 파일시스템이다. 또한 저사양의 서버를 이용해서 스토리지를 구성할 수 있어 기존의 대용량파일스시스템(NAS, DAS, SAN등)에 비해 장점을 가진다. HDFS는 블록 구조의 파일 시스템이다. 파일을 특정크기의 블록으로 나누어 분산된 서버에 저장된다. 블록크기는 64MB에서 하둡2.0부터는 128M로 증가되었다.

#### 특징
1. 블록 단위 저장
   HDFS는 데이터를 블록 단위로 나누어서 저장합니다.
   블록사이즈보다 작은 파일은 기존 파일의 사이즈로 저장하고, 블록 사이즈보다 큰 크기의
   데이터파일은 블록단위 나누어 저장하기 때문에 단일 디스크의 데이터보다 큰 파일도 저장할 수 있습니다.
   블록단위가 256MB일 때 1G파일은 4개의 블록으로 나누어 저장되고, 10MB파일은 하나의 블록으로 저장됩니다.

2. 블록 복제를 이용한 장애 복구
   HDFS는 장애 복구를 위해서 각 블록을 복제하여 저장합니다.
   블록의 기본 복제 단위는 3입니다. 하나의 블록은 3개의 블록으로 복제되고,
   같은 랙(Rack)의 서버와 다른 랙(Rack)의 서버로 복제되어 저장됩니다.
   블록에 문제가 생기면 복제한 다른 블록을 이용해서 데이터를 복구 합니다.

   1G데이터를 저장할 때 데이터가 복제되어 3G의 저장공간이 필요합니다.

3. 읽기 중심
   HDFS는 데이터를 한 번 쓰면 여러 번 읽는 것을 목적으로 합니다. 따라서 파일의 수정은 지원하지 않습니다.
   파일의 수정을 제한하여 동작을 단순화하고 이를 통해 데이터를 읽을 때 속도를 높일 수 있습니다.

4. 데이터 지역성
   맵리듀스는 HDFS의 데이터 지역성을 이용해서 처리 속도를 증가시킵니다.
   처리 알고리즘이 있는 곳에 데이터를 이동시키지 않고,
   데이터가 있는 곳에서 알고리즘을 처리하여 네트워크를 통해 대용량 데이터를 이동시키는 비용을 줄일 수 있습니다.



#### 구조
HDFS는 마스터 슬레이브 구조로 하나의 네임노드와 여러 개의 데이터노드로 구성됩니다.
네임노드는 메타데이터를 가지고 있고, 데이터는 블록 단위로 나누어 데이터노드에 저장됩니다.
사용자는 네임노드를 이용해 데이터를 쓰고, 읽을 수 있습니다.

![HDFS의 구조](image/HDFS 구조)



### 2. 하둡의 구성 요소

1) Hadoop Common
   하둡의 다른 모듈을 지원하기 위한 공통 컴포넌트 모듈

2) Hadoop HDFS
   분산저장을 처리하기 위한 모듈
   여러개의 서버를 하나의 서버처럼 묶어서 데이터를 저장
   파일을 저장하는 방식
   데이터가 어느정도 쌓이면 저장
   실시간처리보다는 배치처리를 위해 설계

3) Hadoop YARN
   병렬처리를 위한 클러스터 자원관리 및 스케줄링 담당

4) Hadoop Mapreduce
   분산되어 저장된 데이터를 병렬 처리할 수 있게 해주는 분산 처리 모듈



### 3. 하둡의 장단점

- 장점
  - 오픈소스로 라이선스에 대한 비용 부담이 적음
  - 시스템을 중단하지 않고, 장비의 추가가 용이(Scale Out)
  - 일부 장비에 장애가 발생하더라도 전체 시스템 사용성에 영향이 적음(Fault tolerance)
  - 저렴한 구축 비용과 비용대비 빠른 데이터 처리
  - 오프라인 배치 프로세싱에 최적화

- 단점
  - HDFS에 저장된 데이터를 변경 불가
  - 실시간 데이터 분석 같이 신속하게 처리해야 하는 작업에는 부적합
  - 너무 많은 버전과 부실한 서포트
  - 설정의 어려움



### 4. 실제 HDFS 플로우

### 파일 저장 플로우

![파일 저장 플로우](image/flow1)

1. 어플리케이션이 HDFS 클라이언트에게 파일 저장을 요청하면,

   HDFS 클라이언트는 네임노드에게 파일 블록들이 저장될 경로 생성을 요청. 

   네임노드는 해당 파일 경로가 존재하지 않으면 경로를 생성한 후,

   다른 클라이언트가 해당 경로를 수정하지 못하도록 락을 검.

   그 후, 네임노드는 클라이언트에게 해당 파일 블록들을 저장할 데이터노드의 목록을 반환

2. 클라이언트는 첫 번째 데이터 노드에게 데이터를 전송

3. 첫 번째 데이터 노드는 데이터를 로컬에 저장한 후, 데이터를 두 번째 데이터 노드로 전송

4. 두 번째 데이터 노드는 데이터를 로컬에 저장한 후, 데이터를 세 번째 데이터 노드로 전송

   5, 6. 로컬에 데이터를 저장하였으면 자기에게 데이터를 넘겨준 데이터 노드에게,

   데이터의 로컬 저장이 완료 되었음을 응답

7. 첫 번째 데이터 노드는 클라이언트에게 파일 저장이 완료 되었음을 응답.

 

### 파일 읽기 플로우

![파일 읽기 플로우](image/flow2)

1. 어플리케이션이 클라이언트에게 파일 읽기를 요청

2. 클라이언트는 네임노드에게 요청된 파일이 어떤 블록에 저장되어 있는지 정보를 요청

3. 메타데이터를 통해 파일이 저장된 블록 리스트를 반환

4. 클라이언트는 데이터 노드에 접근하여 블록 조회 요청

5. 데이터 노드는 클라이언트에게 요청된 블록을 전송

6. 클라이언트를 어플리케이션에 데이터를 전달





## 참고

https://velog.io/@kst5137/7-5-%ED%95%98%EB%91%A1

https://opentutorials.org/course/2908/17055