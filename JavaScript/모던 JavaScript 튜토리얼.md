> https://ko.javascript.info/



- 자바스크립트란?

  - 웹페이지에서 동적이 이벤트를 보여주기 위해서 사용하는 프로그래밍 언어입니다.

- 자바스크립트로 작성한 프로그램은 `script`라고 합니다.

- 스크립트는 `HTML`에서 작성이되고 웹페이지를 불러오면 자동으로 실행됩니다.

- 자바스크립트는 브라우저 뿐만아니라 서버에서도 실행가능합니다. 

  - `Nodejs`

  - 또한 자바스크립트 엔진이 들어있는 모든 디바이스에서도 실행가능합니다.
    - 대표적으로 크롬의 `V8`

- 엔진의 동작방식은 어떤가요?

  1. 엔진이 스크립트를 읽고 (파싱)

  2. 이를 기계어로 변환합니다. (컴파일)

  3. 기계어가 된 코드가 실행되는 식으로 엔진이 동작합니다.

- 엔진은 각 단계마다 최적화를 진행합니다. 컴파일이후에도 기계어를 최적화 진행을 합니다.

- 자바스크립트는 브라우저에서 어떤일을 할수있죠?

  - 웹페이지 조작, 클라이언트와 서버의 상호작용에 관한 모든일을 할 수 있습니다.
    - 페이지에 새로운 요소 추가나 스타일 수정
    - 마우스 클릭같은 사용자 이벤트에 반응이 가능
    - 네트워크에 서버 요청이나 파일 다운,업로드
    - 쿠키를 가져오거나 `alert`
    - 로컬스토리지 사용

- 그럼 할 수 없는 일은요?

  - 보안과 관련해서 자바스크립트 제약을 갖고있습니다.
  - 디스크내 파일에 접근하는 것에 특정방식을 사용해야되며
  - 카메라 마이크 접근에 허가를 받아야합니다.
  - 브라우저에서 별개의 창과 탭끼리는 서로 정보를 공유하지 않습니다.
    - 한 창내에 있을경우는 예외
    - 또한 도메인이나 프로토콜, 포트가 다르면 페이지에 접근불가능 합니다.
      - 이 제약사항을 "동일출처정책" 이라고 합니다.
        - 이를 허가 하기 위해서는 두페이지의 교환에 동의하거나
        - 특수한 자바스크립트 코드가 필요합니다.
    - 이는 해당 페이지가 다른 페이지에 접근하여 개인정보를 훔치는 것을 막기위함입니다.
  - 페이지를 생성한 서버와 정보를 쉽게 주고받을 수 있지만 타사이트는 불가능합니다.
    - 여기는 원격서버에서 허가를 해줘야됩니다. (HTTP 헤더사용)

- 자바스크립트의 장점은 무엇인가요?

  - HTML 과 CSS를 통합할수 있다는점
  - 모든 주요 브라우저에서 지원하고 기본 언어롤 사용된다는 점



-----------



- 웹페이지에서 자바스크립트 코드를 추가하기 위해서는`script` 태그를 사용합니다.
  - HTML 내에서 `script`태그 내에서 코드를 입력하는 경우는 코드가 매우 간단할 때입니다.
    - 그외에는 `src`속성을 사용해서 js 파일을 불러와서 사용합니다.
    - 이러면 브라우저가 스크립트를 다운받아 캐시에 저장하기 때문에 성능상 이점도 있습니다.



--------



- 자바스크립트가 발전해오면서 옛날 코드와 호환성 문제를 없애기 위해서 strict모드가 활성화 되어있지 않습니다. 

- 하지만 `use strict`을 사용해서 모던 자바스크립트의 변경사항을 활성화해야합니다.

  - 스크립트 최상단에 써야합니다. 반드시

  - ```
    "use strict";
    ```

  - 이러게 작성하면 스크립트 전체가 "모던한" 방식으로 동작합니다.

  - 그런데 브라우저 콘솔에서창에서는 적용되지 않습니다.

    - 브라우저 콘솔창에서 쓰기위해서는 콘솔창에 `"use strict";` 적고 `shift+enter` 하고 코드를 이어서 쓰면 됩니다.

  - 근데 모던 자바스크립트에서 "모듈","클래스" 를 사용한다면 자동으로 적용됩니다.



------------



- 함수형 프로그래밍에서 변숫값 변경을 금합니다.
- 변수명에 특수기호는 반드시 `$` 와 `_` 만 허용됩니다.
- 대소문자를 구별합니다.
- 변수명 선언에는 대부분 카멜 기법을 사용합니다.
- 예약어는 사용금지 합니다.

- `const`는 상수입력에 사용됩니다.
  - 대문자 상수를 이용하는 것은 널리 사용되는 관습입니다.
  - 대문자 상수는 하드코딩한 값을 쓸때 사용됩니다.
    - 예시 `#FF231` 색상같은거
- 변수를 재사용하는 것은 디버깅에 큰 시간을 들게 합니다. 변수 선언을 통해 새로 만듭시다
  - 모던 자바스크립트 압축기와 브라우저는 코드최적화를 잘해줍니다!



----------



- 자바스크립트는 동적타입언어이다. 변수에 저장되는 값에 따라 타입이 변경된다는 것이다.
- 타입은 8가지의 기본 자료형을 갖고있습니다.
- `Number` `숫자형`을 다룰 때 에러상황이 나타난다면 `NaN`을 반환됩니다.
- `BigInt`는 아주 큰숫자를 나타내기위해서 길이에 상관없이 정수를 나타내줍니다.
  - `214234234n` 숫자 뒤에`n`이 붙으면 `BigInt`형입니다.
  - 많이 사용되지는 않지만 암호관련 작업에 사용됩니다.

- `string` `문자형`은 백틱(`) 사이에 ${} 를 통해서 변수나 표현식을 넣을 수 있습니다.
- `불린형` 은 `true` 와 `false` 만 존재합니다.
- `null` 은 값이 없음을 나타냅니다.
  - 출력시 `object`입니다. 이것은 언어자체의 버그입니다.
- `undefined` 은 값이 아직 할당되지 않았음을 나타냅니다. 하지만 직접적으로 할당하진 않습니다.
- `객체형`은 복잡한 개체를 표현할수있습니다. 위의 원시자료형과는 다릅니다.
  - 함수는 객체형에 속합니다. type이`function`으로 나오는 것은 오래된 규칙입니다.
- `심볼`은 객체의 고유한 식별자를 만들때 사용됩니다.



-----------------------



- `alert`는 모달창을 생성합니다. 모달창 이외의 것과는 상호작용이 불가능 합니다.

- `prompt` 는 메세지, 입력필드, 확인, 취소있는 모달창을 생성합니다.

  - ```js
    let result = prompt(title:메세지, [default:초기값]);
    ```

  - `[]`는 필수가 아닌 선택값이란 뜻

  - 입력취소하면 `null`이 반환되고 확인이되면 입력된 문자열이 반환됩니다.

  - IE 를 위해서 기본값을 넣어줍시다.

- `confirm`은 매개변수로 받은 질문과 확인 취소가 있는 모달창을 생성합니다.

  - 확인을 누르면 `true` 가 취소면 `false`가 반환됩니다.

  - ```js
    let result = confirm('남자입니까?')
    ```



-----------



- 자바스크립트는 암묵적으로 형변환이 진행됩니다.
- 빈문자열 `""` 과 숫자 `0` 은 불린에서 `false`로 변환됩니다.
- 숫자의 경우 
  - `null`은  `0` 
  - `undefined`는 `NaN` 입니다. 
  - `string`의 경우 처음과 끝의 공백을 제외하면서 변환됩니다.
  - `\t` `\n` 은 길이가 0인 문자열로 취급되므로 숫자 `0`이 됩니다.



---------



- `+` 연산자가 다른 연산자와 다른점은 피연산자로 `string`이 있는경우 따라서 형변환이 일어난다는 점입니다.

  - 나머지는 숫자로 변환됨

  - ```
    alert(2+2+'1') // 41 이 출력된다.
    alert("2"+2+1) // 221 이 출력된다.
    alert(2-1-"1") // 0 이 출력된다.
    ```

- `,`쉼표 연산자는  코드를 짧게 쓰기위한 의도이고 마지막 표현식의 평가 결과감 반환됩니다.

  - ```
    // 한 줄에서 세 개의 연산이 수행됨
    for (a = 1, b = 3, c = a * b; a < 10; a++) {...}
    ```

  - 이런식으로 사용됩니다. 그런데 가독성이 좋지않아 진짜 필요한 경우에만 씁시다.



--------



- 문자열 비교시 유니코드 순으로 따지고 길이순으로 따집니다. 
  - 'a' > 'A' 입니다.
  - 숫자랑 비교시에는 변환이 진행됩니다.
- `==` 는 `0`과 `false`를 구별하지 못합니다.
  - 그래서 `===`를 사용하면 형변환 없이 비교를 진행합니다.

- `==`는 `null`과 `undefined`를 같다고 비교합니다.
  - 이는 특수한 케이스이며 `null`과 `undefined`는 `==` 사용 시 형변환을 거치지 않습니다.
  - 그래서 무조건 `false`를 출력합니다.



-----------



- `&&`는 `||`보다 우선순위가 높습니다.
- `!!`를 씀으로서 `불린형`으로 만들 수 있습니다.



---------------



- `nullish` `??`
  -  `a ?? b` a가 `null`도 아니고 `undefined`도 아니면`a`이고 그외에는 `b`이다.
  - `||` 와의 차이는 반환값의 차이입니다.



----------------



- `?` 사용에는 `break`, `continue`를 사용할수없습니다. `if`를 씁시다.



-------



- 반복문 사용시 원하는 곳으로 `break`, `continue`를 하고 싶다면 `label`을 사용하면됩니다.

  - ```js
    here: for(let i=3; i<4; i++){
        for (let j=3; j<4; j++){
            if (i>j){
                break here; //이럼 here 위치로 break가 일어남 아예밖으로 나오게됨
            }
        }
    }
    ```





-----------



- 스크립트 내에서 `debugger;` 를 사용하면 중단점을 설정한 것 과은 효과를 낸다.



-----------



- 유명한 자바스크립트 스타일 가이드
  - [Google의 자바스크립트 스타일 가이드](https://google.github.io/styleguide/jsguide.html)
  - [Airbnb의 자바스크립트 스타일 가이드](https://github.com/airbnb/javascript)
  - [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)
  - [StandardJS](https://standardjs.com/)

- Linter를 사용하면 코드가 스타일 가이드를 준수하고있는지 자동으로 확인할 수 있다.

  - 오타 등 버그도 확인이 가능해서 좋다.

  - [JSLint](http://www.jslint.com/) – 역사가 오래된 linter

  - [JSHint](http://www.jshint.com/) – JSLint보다 세팅이 좀 더 유연한 linter

  - [ESLint](http://eslint.org/) – 가장 최근에 나온 linter

    1. [Node.js](https://nodejs.org/)를 설치합니다.

    2. npm(자바스크립트 패키지 매니저)을 사용해 다음 명령어로 ESLint를 설치합니다. `npm install -g eslint`

    3. 현재 작성 중인 자바스크립트 프로젝트의 루트 폴더(프로젝트 관련 파일이 담긴 폴더)에 `.eslintrc`라는 설정 파일을 생성합니다.

    4. 에디터에 ESLint 플러그인을 설치하거나 활성화합니다. 주요 에디터들은 모두 ESLint 플러그인을 지원합니다.

  - 설치방법: http://eslint.org/docs/user-guide/getting-started



----------



- 좋은 주석
  - 아키텍처를 설명하는 주석
    - 컴포넌트의 개요, 컴포넌트 간의 상호작용에 대한 설명
    - 상황에 따른 제어흐름
  - 함수 용례와 매개변수 정보를 담고 있는 주석
    - JSDoc 을 사용하면 함수에 관한 문서를 쉽게 작성이 가능하다.
  - 왜 이런방법으로 문제를 해결했는지를 설명하는 주석
    - 이미 햇던 방법을 새로 시도하게 만들지 않는것만으로 충분하다.
    - 최근 redux로 상태관리했으나 결국 로컬스토리지 사용을 하는게 나았다는게 떠오름..
  - 미묘한 기능이 있고 이기능이 어디에쓰이는지 설명하는 주석
- 안좋은 주석
  - 코드가 어떻게 동작하는지
  - 코드가 상세하게 무엇을 하는지



------------



- BDD 방법론
  - 테스트, 문서, 예시를 한데 모아놓은 개념

- BDD 명세서(spec)

```js
describe("pow", function() { //describe 첫 인수 - 구현하는 기능(title), 
  it("주어진 숫자의 n 제곱", function() { //it 첫 인수 -유스케이스설명, 테스트함수
    assert.equal(pow(2, 3), 8);//assert가 함수가 예상대로 동작하는지 확인 equal사용되서 8과 같은지 비교할것임
  });
});// 테스트마다 it 블록을 생성해서 진행
```



- 개발 순서

  1. 명세서 초안을 작성합니다. 초안엔 기본적인 테스트도 들어갑니다.

  2. 명세서 초안을 보고 코드를 작성합니다.

  3. 코드가 작동하는지 확인하기 위해 [Mocha](http://mochajs.org/)라 불리는 테스트 프레임워크를 사용해 명세서를 실행합니다.(Mocha에 대해선 아래에서 다룰 예정입니다.) 이때, 코드가 잘못 작성되었다면 에러가 출력됩니다. 개발자는 테스트를 모두 통과해 에러가 더는 출력되지 않을 때까지 코드를 수정합니다.

  4. 모든 테스트를 통과하는 코드 초안이 완성되었습니다.

  5. 명세서에 지금까진 고려하지 않았던 유스케이스 몇 가지를 추가합니다. 테스트가 실패하기 시작할 겁니다.

  6. 세 번째 단계로 돌아가 테스트를 모두 통과할 때까지 코드를 수정합니다.

  7. 기능이 완성될 때까지 3~6단계를 반복합니다.

- 사용되는 라이브러리
  - [Mocha](http://mochajs.org/) – 핵심 테스트 프레임워크로, `describe`, `it`과 같은 테스팅 함수와 테스트 실행 관련 주요 함수를 제공합니다.
  - [Chai](http://chaijs.com/) – 다양한 assertion을 제공해 주는 라이브러리입니다. 우리 예시에선 `assert.equal` 정도만 사용해 볼 예정입니다.
  - [Sinon](http://sinonjs.org/) – 함수의 정보를 캐내는 데 사용되는 라이브러리로, 내장 함수 등을 모방합니다. 본 챕터에선 사용하지 않고, 다른 챕터에서 실제로 사용해 볼 예정입니다.

```html
<!DOCTYPE html>
<html>
<head>
  <!-- 결과 출력에 사용되는 mocha css를 불러옵니다. -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
    
  <!-- Mocha 프레임워크 코드를 불러옵니다. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // 기본 셋업
  </script>
    
  <!-- chai를 불러옵니다 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai의 다양한 기능 중, assert를 전역에 선언합니다.
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* 코드를 여기에 작성합니다. 지금은 빈칸으로 남겨두었습니다. */
    }
  </script>

  <!-- 테스트(describe, it...)가 있는 스크립트를 불러옵니다. -->
  <script src="test.js"></script>

  <!-- 테스트 결과를 id가 "mocha"인 요소에 출력하도록 합니다.-->
  <div id="mocha"></div>

  <!-- 테스트를 실행합니다! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
```



- 함수 `before`는 (전체) 테스트가 실행되기 전에 실행되고, 함수 `after`는 (전체) 테스트가 실행된 후에 실행됩니다. 함수 `beforeEach`는 *매* `it`이 실행되기 전에 실행되고, 함수 `afterEach`는 *매* `it`이 실행된 후에 실행됩니다.
  - `beforeEach/afterEach`와 `before/after`는 대개 초기화 용도로 사용됩니다. 카운터 변수를 0으로 만들거나 테스트가 바뀔 때(또는 테스트 그룹이 바뀔 때)마다 해줘야 하는 작업이 있으면 이들을 이용할 수 있습니다.

- BDD의 핵심은 실패할 수밖에 없는 테스트를 추가하고, 테스트를 통과할 수 있게(에러가 발생하지 않게) 코드를 개선하는 것이다.



------------



주목할 만한 폴리필

- [core js](https://github.com/zloirock/core-js) – 다양한 폴리필을 제공합니다. 특정 기능의 폴리필만 사용하는 것도 가능합니다.
- [polyfill.io](http://polyfill.io/) – 기능이나 사용자의 브라우저에 따라 폴리필 스크립트를 제공해주는 서비스입니다.



----------























