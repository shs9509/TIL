# 문서



## 브라우저 환경과 다양한 명세서

- 자바스크립트가 돌아가는 플랫폼을 `호스트`라고 한다.
  - 호스트는 브라우저, 웹서버 등을 말할 수 있다.
- 각 `호스트`들은 해당 플랫폼에 맞는 기능들을 제공하는데 이를 자바스크립트 명세서에서 `호스트 환경`이라고 한다.
  - `호스트 환경`은 `ECMAScript`+ 플랫폼에 특정되는 객체와 함수를 제공합니다.
    - 웹브라우저는 웹페이지를 제어하기위한 수단을 제공
    - 노드는 서버사이드 기능을 제공

- 호스트 환경이 웹브라저일경우 최상위 루트 객체는 `window` 입니다.

  - `window`는 자바스크립트 코드의 전역객체이고

    - ```js
      function sayHi() {
        alert("안녕하세요.");
      }
      // 전역 함수는 전역 객체(window)의 메서드임
      window.sayHi();
      ```

  - 브라우저 창을 대변하고 이를 제어하는 메서드를 제공합니다.

    - ```js
      alert(window.innerHeight);
      ```

      

- `DOM`은 XML 이나 HTML 문서에 접근하기 위한 인터페이스로 웹페이지 내 모든 콘텐츠를 객체로 나타내줍니다.

  - `document`객체는 페이지의 기본 진입점 역할을 합니다.
    - `document`를 거쳐서 뭔가를 수정하고 만들수 있다!!

  - 브라우저 뿐만아니라 서버사이드 스크립트에서도 사용됩니다. 
    - html을 다운로드하고 가공

  ```
  DOM은 xml이나 html 문서에 접근하기위해서 사용되는 문서로서 웹페이지내의 모든 콘텐츠들을 객체로 나타내줍니다.
  ```

- CSS 규칙과 스타일시트를 객체로 나타내고 어떻게 읽고, 쓸지를 설명이 적힌 명세서를 `CSSOM` 이라고 합니다. 

- `BOM`은 문서 이외의 모든것을 제어하기 위해 브라우저(호스트 환경)가 제공하는 추가 객체 입니다.
  - 예시로 `alert`,`confirm` 등이 있습니다.
  - 이는 HTML 명세의 일부입니다.



## DOM 트리

- DOM 에 따르면 모든 HTML의 태그는 객체입니다.
  - `document.body`는 `<body>`태그를 객체로 나타낸것

- DOM은 HTML을 태그의 트리구조로 표현합니다.
  - `<html>`은 루트노드
  - 그외에는 요소노드 
  - 그안의 문자는 텍스트 노드 이는 트리 끝에 있기때문에 리프노드라고 합니다.
- HTML 명세서에서 모든 콘텐츠는 `body` 안쪽에 있어야 한다고 했으므로, 
  - `</body>` 뒤에 무언가를 넣더라도 그 콘텐츠는 자동으로 `body` 안쪽으로 옮겨집니다. 
  - 따라서 `</body>` 뒤엔 공백이 있을 수 없습니다.

- DOM 생성과정에서 HTML은 자동 교정됩니다.
  - table 태그 사용시 `tbody`는 항상 추가됩니다. 
  - 닫는태그가 없으면 넣어줍니다.

- HTML 안에 모든것이 DOM을 구성합니다. (주석도)



## DOM 탐색하기

- `<html>` : `document.documentElement`

- `<body>` : `document.body`

- `<head>` : `document.head`

- `childNodes`: 텍스트 노드를 포함한 모든 자식노드를 담고 있습니다. (이터러블한 유사배열입니다.)

  - *// Text, DIV, Text, UL, ... , SCRIPT*
  - `firstChild`: 첫번째 자식노드에 접근
  - `lastChild`: 마지막 자식노드에 접근
  - `hasChildNodes()`: 자식노드의 존재 여부 확인

  - `Array.from`으로 배열로 만들고 `filter`같은 배열 메소드를 사용할수있습니다.
    - `for.. in`은 절대 쓰지말자.

- 같은 부모를 가진 노드를 형제노드라고 합니다.

  - 형제노드는 `nextSibling`, `previousSibling`으로 찾습니다.
  - 부모노드는 `parentNode`( 노드 종류에 상관없이 )

- 지금까지는 모든 노드를 탐색한다. 하지만 주석노드나 텍스트 노드는 다루지 않습니다. 

  - 요소 노드만 가리킵시다.

  - `children`

    - *// DIV, UL, DIV, SCRIPT*

  - `firstElementChild`

  - `lastElementChild`

  - `previousElementSibling`, `nextElementSibling`

  - `parentElement` ( 대부분 `parentNode` 와 같은걸 반환함)

    - ```js
      alert( document.documentElement.parentNode ); // document
      alert( document.documentElement.parentElement ); // null
      ```

- DOM 요소 노드는 편의를 위해서 추가적인 프로퍼티를 제공합니다.

  - 대표적으로 테이블

  - ```js
    <table id="table">
      <tr>
        <td>일</td><td>이</td>
      </tr>
      <tr>
        <td>삼</td><td>사</td>
      </tr>
    </table>
    
    <script>
      // '이'가 적힌 td를 가져옴(첫 번째 줄, 두 번째 칸)
      let td = table.rows[0].cells[1];
      td.style.backgroundColor = "red"; // 강조
    </script>
    ```

    

## getElement*, querySelector*로 요소 검색하기



- `document.getElementById(id)` id로 요소 접근

  - id 는 유일 무이해야 됨

- `elem.querySelectorAll(css)` :  css에 해당되는 선택자에 모든 요소를 반환함

  - ```js
    let elements = document.querySelectorAll('ul > li:last-child');
    ```

  - `:hover`같은 가상 클래스도 사용가능

- `elem.querySelector(css)`: 첫번째요소를 반환

  - `elem.querySelectorAll(css)[0]` 이랑 같음
  - 근데 더빠름

- `elem.matches(css)` : 요소 elem 이 주어진 CSS선택자와 일치하는지 판단 (true, false 반환)

  - ```js
    <a href="http://example.com/file.zip">...</a>
    <a href="http://ya.ru">...</a>
    
    <script>
      // document.body.children가 아니더라도 컬렉션이라면 이 메서드를 적용할 수 있습니다.
      for (let elem of document.body.children) {
        if (elem.matches('a[href$="zip"]')) {
          alert("주어진 CSS 선택자와 일치하는 요소: " + elem.href );
        }
      }
    </script>
    ```

- `elem.closest(css)` : elem 자기 자신을 포함해서 css 선택자와 일차하는 가장가까운 조상요소(상위요소만!)

- 안씀 `querySelector` 씀

  - `elem.getElementsByTagName(tag)` 

  - `elem.getElementsByClassName(className)` 

  - `document.getElementsByName(name`

- `getElementsBy`로 시작하는 모든 메서드는 동적인 컬렉션을 반환 (실시간으로 바뀜)
  - `querySelectorAll` 은 정적인 컬렉션을 반환 (중간에 바뀌지 않음)



## 주요노드 프로퍼티



- DOM 노드의 종류에 따라 다른 프로퍼티를 지원합니다.
- 객체에는 `constructor`프로퍼티를 가지는 여기서 `name`을 조회하면 DOM노드의 클래스 이름을 확인할 수 있다.
  - `toString`을 사용해도되고
  - `instanceof`를 사용하면 상속 여부를 확인가능하다.

- 가끔 간단한게 노드의 타입을 확인할때는 `nodeType`을 사용하면된다.
- `nodeName` : DOM 노드의 태그 이름을 알아낼 수 있습니다. ( 요소 노드에 한정)
- `tagName` :  DOM 노드의 태그 이름을 알아낼 수 있습니다.  ( 모든 Node에 가능)
  - 요소 노드가 아니면 노드타입을 반환

- `innerHTML`프로퍼티를 사용해서 요소안의 HTML을 문자열(HTML형태로)로 받아옵니다.

  - 수정도 가능합니다.
  - 내용을 덮어씁니다.
    - `innerHTML+=` 이면 기존껄 삭제하고 새로운 내용이 들어감
    - 이는 리소스가 전부 다시 로딩됩니다 (부작용!!)

- `outerHTML` 프로퍼티엔 요소 전체 HTML 담겨있다.

  - ```js
    <div id="elem">Hello <b>World</b></div>
    
    <script>
      alert(elem.outerHTML); // <div id="elem">Hello <b>World</b></div>
    </script>
    ```

  - **`innerHTML`과 달리 `outerHTML`을 사용해서 HTML을 쓸땐 요소 자체가 바뀌지 않습니다. 대신 `outerHTML`은 DOM 안의 요소를 교체합니다.**

    - 문서에서 삭제를 하고 교체하지만 기존값은 계속 저장되어있는 상태
    - `outerHTML`로 인한 새로은 HTML은 어디에도 저장되지 않음

- `innerHTML`은 요소노드에만 적용됩니다. `data`, `nodeValue`는 다른 타입의 노드에서 사용가능합니다.

  - ```js
    <body>
      안녕하세요.
      <!-- 주석 -->
      <script>
        let text = document.body.firstChild;
        alert(text.data); // 안녕하세요.
        let comment = text.nextSibling;
        alert(comment.data); // 주석
      </script>
    </body>
    ```

- `textContent` 는 요소내의 텍스트에 접근가능합니다.

  - ```js
    <div id="news">
      <h1>주요 뉴스!</h1>
      <p>화성인이 지구를 침공하였습니다!</p>
    </div>
    
    <script>
      // 주요 뉴스! 화성인이 지구를 침공하였습니다!
      alert(news.textContent);
    </script>
    ```

    - 읽기 단독보단 쓰기용으로 씀

- `hidden`을 쓰면 요소를 안보여줄 수 있습니다.
  - `style="display:none"` 와 동일합니다.



## 속성과 프로퍼티

- 브라우저는 웹페이지를 만나면 HTML을 파싱하고 DOM 객체를 생성합니다.
- 요소노드에서 HTML의 속성은 DOM 객체의 프로퍼티가 됩니다.
  - 태그 `<body id="page">`가 있을 때, DOM 객체에서 `body.id="page"`
- DOM 노드는 자바스크립트의 객체이기에 메소드나 프로퍼티를 추가하여 사용할 수 있습니다.
- 태그에는 `id`같은 표준 속성이면 자연스레 DOM프로퍼티가 만들어집니다.
  -  표준이 아니면 `undefined`를 반환합니다.
  - 하지만 비표준 속성도 접근은 가능합니다.
    - `elem.hasAttribute(name)` – 속성 존재 여부 확인
    - `elem.getAttribute(name)` – 속성값을 가져옴
    - `elem.setAttribute(name, value)` – 속성값을 변경함
    - `elem.removeAttribute(name)` – 속성값을 지움
    -  `elem.attributes`을 사용하면 모든 속성값을 읽을 수 있습니다.
  - HTML 속성은 대소문자를 가리지않습니다. 
    - 항상 문자열 입니다.

- 표준 속성이 변경되면 프로퍼티는 자동으로 갱신됩니다.(생긴가 바뀌는등)
  - 반대도 마찬가지
  - 그런데  `input.value`처럼 속성이 바뀔때만 프로퍼티가 바뀌는 예외가 있습니다.
    - value를 바꿔도 `input.getAttribute('value')`는 그대로!

- DOM 속성에는 불린이 들어갈수도 있고 style 의 경우 객체입니다.

- 비표준 속성이 쓰이는 것은 HTML에서 JS로 데이터를 넘기거나

  -  JS를 사용해서 HTML을 조작하기 위한 요소로 쓰입니다.

  - 스타일을 적용할 때

    - ```js
      <style>
        /* 스타일이 커스텀 속성 'order-state'에 따라 변합니다. */
        .order[order-state="new"] {
          color: green;
        }
      </style>
      
      <div class="order" order-state="new">
        A new order.
      </div>
      ```

- 비표준 속성이 표준속성이 될수있기 때문에 `data-`를 사용해서 미연에 방지합니다.

  - `data-`로 시작하는 속성전체는 `dataset`프로퍼티로 접근이 가능합니다.

    - ```js
      <body data-about="Elephants">
      <script>
        alert(document.body.dataset.about); // Elephants
      </script>
      ```

    - `data-order-state`의 경우 카멜케이스로`dataset.orderState`로 변환
