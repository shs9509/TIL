# 원시값과 객체의 비교

데이터타입은 크게 원시타입과 객체타입으로 구분이된다.



- 원시타입
  - 변경불가능한값
  - 변수에 할당하면 실제 값이 저장된다.
  - 다른 변수에 원시값을 할당하면 복사되어서 값이 전달된다. "값에 의한 전달"
- 객체타입
  - 변경가능한값
  - 변수에 할당하면 참조값이 저장된다.
  - 참조값이 복사되어서 전달된다. "참조에 의한 전달"



## 원시값

### 변경불가능한 값

원시값은 읽기전용값으로 변경이 불가능하다. 

> 변수값이랑은 다름 그냥 값 자체가 안바뀐다는 소리
>
> 변수값은 그저 재할당하면 바뀐다.
>
> 그중 상수는 재할당이 금지된 변수일뿐이다.



변수를 할당하면 메모리의 위치가 변하는것을 볼 수 있다.

이는 값을 못바꾸니, 메모리 공간의 주소를 바꾸는 것!



```js
var str ='string';

str[0] = 'S';
console.log(str); // string
```

위는 문자열의 불변성을 보여준 예시이며 이불변성은 데이터의 신뢰성을 보장한다.



### 값에 의한 전달

```js
var score =80;
var copy = score;
score = 100;
console.log(copy);//80
```

`score`의 값인 80이  복사되서 copy에 넣어진다.

복사되서 넣은거라 score가 바뀌었다고 해서 바뀌지가 않는다. 아예 별개의 공간이다.





## 객체값

### 변경가능한 값

변수에 객체를 할당하면 변수에는 객체의 주소값이 들어가있고 그 주소로 값에 접근한다.

즉슨, 변수로 참조값에 접근할수있다.

> 정리하면
>
> 원시값을 할당한 변수는 바로 원시값에 접근하고,
>
> 객체값을 할당한 변수는 객체에 접근할수있는 참조값을 접근하는 것이다.



객체가 변경이 불가능하게 된다면 그만큼 큰 객체를 복사하면서 사용해야하는데 비용이 너무커진다.

이러한 구조는 여러개의 식별자가 하나의 객체를 공유할수있다는 부작용있다.



### 참조에의한 전달

```js
var person ={
    name:'Lee'
};
var copy = person;
copy.name ='Kim';
person.address = 'Seoul';

console.log(copy);//{name: 'Kim', address: 'Seoul'}
console.log(person);//{name: 'Kim', address: 'Seoul'}
```

식별자가 객체를 공유하기 때문에 객체의 수정이 서로에 영향을준다.









