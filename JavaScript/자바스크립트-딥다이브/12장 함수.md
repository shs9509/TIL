# 함수

함수 :  일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한것

- 코드의 **재사용**
- 유지보수의 **편의성**
- 코드의 **신뢰성**을 높임

- 함수는 객체 타입의 값이므로 식별자를 붙일 수 있다.
  - 코드의 **가독성**을 높임



## 함수 리터럴

함수리터럴은 `function`키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성됨

```js
let add = function add(a,b){
	return a+b;
};
```

함수는 **객체**다.

함수 객체와 일반 객체와 다른 점은 **"호출가능"** 이라는 점이다.



## 함수 정의

함수를 정의하는 방식에는 여러가지 방법이 존재한다.



### **함수 선언문**

- ```js
  function add(a,b){
      return a+b;
  };
  ```

- 함수 리터럴과 동일한 형태

- 함수 선언문은 함수 이름을 생략할 수 없다.

- 함수 선언문은 표현식이 아닌 **"문"**이다. ->변수에 할당불가능 (근데 막상 변수에 할당하면 됨 ㅋ)

  - 자스 엔진이 문맥에 따라 **함수 리터럴 표현식**으로 해석하기 때문

  - 변수 없이 단독으로 쓰면 **함수 선언문**으로 해석 

  - ```js
    function add(a,b){return a+b;};  //함수 선언문
    (function add() {console.log('add'); }); //이렇게 피연산자면 함수 리터럴 표현식
    ```

![image-20211229212528365](C:\Users\PRO\AppData\Roaming\Typora\typora-user-images\image-20211229212528365.png)



> **왜 함수 리터럴 표현식일 때는 않되는가????**
>
> 함수 리터럴 표현식에서는 함수를 가리키는 식별자가 없기 때문
>
> 함수 선언문은 자스엔진이 **암묵적으로** 함수이름과 동일한 이름의 식별자를 생성하고 할당한다. 
>
> 그리고 그 식별자를 불러서 함수를 호출함!
>
> ```js
> let add = function add(a,b){return a+b;}; //이런 느낌 
> ```



### **함수 표현식**

- ```js
  let add = function(a,b){
      return a+b;
  };
  ```

- 변수에 함수를 할당할 수 있는 것은 **일급객체 함수**의 성질이다.

- 함수 이름은 생략이 가능하다. 이를 **익명함수** 라고 한다.



#### 함수 생성시점과 호이스팅

:fire: **함수 표현식 권장**:fire: 

- 함수 표현식
  - 변수 호이스팅이 일어남
  - 변수는 할당전에 `undefined`가 되니깐 ㄱㅊㄱㅊ
- 함수 선언문 
  - 함수 호이스팅이 일어남
  - 런타임 이전에 함수 객체가 생성됨



### **Function 생성자 함수**

- ```js
  let add = new function('a','b','return a+b');
  ```

- 일반적이지 않고 바람직하지 않음
- 클로저를 생성안할뿐더러 이전 표현식과 선언문과 다르게 작동한다.



### **화살표 함수(ES6)**

- ```js
  let add = (a,b) => a+b;
  ```

- ES6에 도입된 개념

- 표현 뿐만아니라 내부동작까지 간략화 됨
- this 바인딩, prototype 프로퍼티가 없으며, argument를 생성하지 않는다.



## 함수 호출

### 매개변수와 인수

```js
let add = function(a,b){ //매개변수 a,b
    return a+b;
};

add(2,4); //인수 2,4
```

- 매개변수의 스코프는 함수 내부다.
- 인수들은 arguments 객체의 프로퍼티에 저장된다.
  - 인수가 부족한경우 `undefined`처리로 `NaN`이 반환된다.
  - 초과된 인수의 경우 무시된다.
  - arguments 는 가변인수의 경우 도움이된다.



### 인수확인

그러면 인수가 제대로 오든말든 자스엔진은 하던일 그대로 할것이다. 참으로 문제다. :sweat:

그래서 올바른 방법은

- 타입스크립트 같은 정적타입을 선언해서 컴파일에서 부적절한 호출 방지
- 단축평가를 통해서 기본값 할당하기
- ES6의 매개변수 기본값 할당하기

가 있다.



### 매개변수의 최대 개수

- 많으면 유지 보수성이 나빠진다.

- 가급적 3개를 넘지 않는것을 권장한다.
- 3개보다 많다면.,,, 객체를 인수로 전달하는 것이 유리하다. ( +가독성, +실수방지) (-부수효과 발생)



### 반환문

함수는 return 키워드와 표현식으로 이루어진 반환문으로 실행결과를 외부에 반환한다.

- 반환문 역할
  - 함수의 실행을 중단하고 함수 몸체를 벗어난다.
  - return 키워드 뒤에오는 표현식을 평가해 반환한다.
    - 생략이 가능하며, 따라오는것은 `undefined` 다.
    - 함수 내부에서만 써야한다.



## 참조에 의한 전달과 외부상태의 변경



## 다양한 함수의 형태



### 즉시 실행함수



### 재귀함수



### 중첩함수



### 콜백함수



### 순수함수 / 비순수함수



