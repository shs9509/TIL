# 변수

> 자바스크립트 딥 다이브



누구에게나 익숙한 변수이지만 자바스크립트에서 변수는 어떤지 알아보자.



## 기본적인 내용

### 변수?

변수는 프로그래밍 언어에서 데이터를 관리하기위한 핵심 개념이다.



```
10+20
```

위를 계산하려면 10, + , 20 을 알아야한다.

컴퓨터는 CPU를 통해서 연산을 하고 , 메모리를 통해서 데이터를 기억한다.



>메모리
>
>메모리 셀의 집합자, 메모리셀 하나의 크기는 1바이트(8비트)이다.
>
>각 셀은 고유의 메모리 주소를 같는다. 
>
>메모리 주소는 메모리 공간의 위치이다.



10과 20을 메모리 임의의 위치에 저장을 하고 CPU가 이를 읽고 연산을 하는것이다.

연산 결과 30 역시 메모리에 저장이된다.



30을 사용하기 위해서는 어떻게 해야할까?

메모리 주소를 통해서 직접 접근하는것을 매우 위험하다.

그래서 사용하는 것이 '변수'이다.



**변수**는 하나의 값을 저장하기위해 확보한 메모리 공간을 말하며, 그 공간을 식별하기위한 붙인 이름이다.

- 값의 위치를 가리키는 상징적인 이름이다.
- 변수 이름을 통해서 가독성을 높일 수 있다.



### 식별자?

그럼 **식별자**는 무엇인가??

**식별자**는 어떤값을 구별해서 식별할 수있는 고유한 이름을 말한다.

그래서 변수이름을 식별자라고도 한다. 물론 클래스,함수 이름 모두 식별자라고 한다.



식별자는 값이 저장되어있는 메모리 주소와 매핑관계를 맺으며, 매핑정보 역시 메모리에 저장되야한다.

식별자는 값이 아니라 **메모리 주소**를 기억하고 있다.



쉽게, "메모리 주소에 붙인 이름" 이라고 기억하자





## 자바스크립트의 변수

### 변수 선언

변수 선언을 자세히 설명하자면,

값을 저장하기 위한 "메모리 공간을 확보"하고

"변수 이름과 확보한 메모리 공간을 연결"하여 "값을 넣을수있게 준비"하는 과정이다.



자바스크립트에서 변수를 선언하는데 

키워드 `var`, `let`, `const` 가 사용된다. 



> ES6 이후 `var`의 단점을 개선하기 위해  `let`, `const`이 생겨났다.
>
> 그렇다고 `var`가 쓰이지 않는것은 아니다.
>
> `var` 의 단점은 함수 레벨 스코프를 지원한다는 점
>
>  `let`, `const`은 블록 레벨 스코프를 지원한다.



> 키워드:
>
> 자바스크립트 엔진이 수행할 동작을 규정한 명령어다.
>
> `var` 라는 키워드를 만나면 뒤에있는 변수 이름으로 변수를 생생하는 동작을 진행한다.



```js
var score;
```

위의 변수 선언으로 인해서

score 라는 이름으로 변수가 선언되며, 메모리 공간을 확보하고 `undefined`를  할당해서 초기화 한다.

이것은 자바스크립트의 특징이다.

즉, 값을 할당하지않으면  `undefined`가 채워져있다는 것이다.

메모리 낭비가 아닌가??? 할수있지만 이는 나중에 가비지 컬렉터에 의해 비워진다.



변수를 사용하기 위해서는 반드시 선언이 필요하다.



>식별자의 저장
>
>모든 식별자는 실행 컨텍스트에 저장이된다.
>
>> 실행 컨텍스트 :
>>
>> 자바스크립트 엔진이 소스코드를 평가를 하고 실행하기 위해 환경을 제공하고 
>>
>> 코드의 실행 결과를 실제로 관리하는 영역
>>
>> 자바스크립트 엔진은 실행 컨텍스트를 통해서 식별자와 스코프를 관리한다.



### 호이스팅

```js
console.log(score); //undefined
var score;
```

콘솔 로그를 보면  score를 뒤에서 선언했음에도 `undefined` 가 뜬다.

이는 자바스크립트 엔진이 소스코드 평가를 거치면서 이미 변수,함수 선언 같은것을 이미 찾아내서 실행하여 실행환경을 구성하기 때문이다.

이 과정을 거치고 소스코드가 순차적으로 실행된다.



이처럼 변수 선언문이 코드를 선두로 끌어 올려진 것처럼 동작하는 것을 **호이스팅** 이라고 한다.

모든 선언문이 런타임 이전에 실행되기 때문에 이는 자바스크립트 고유의 특징이다.



### 변수 할당

```js
//(1)
var score;
score = 80;

//(2)
var score =80;
```



우리는 이미 score 가 런타임 이전에 변수로서 선언되었다는 것을 안다.

그리고 값의 할당은 그이후, 런타임에서 실행된다는 것이다.

참고로 (2) 경우라해도 (1)의 과정으로 풀어서 진행된다.



```js
console.log(score); // undefined
score = 80;
var score;
console.log(score); // 80
```



신기한것은 "선언과정"에서 확보한 메모리(undefined가 들어간)를 

"할당과정"에서는 새로 메모리를 확보하고 값을 넣는다는 것이다.

값을 재할당하는 경우에도 값은 방식으로 진행된다.



그러면 메모리 낭비가 아닌가? 여전히 가비지콜렉터가 관리를 해준다.

>메모리 관리 방식에따라
>
>매니지드언어와 언매니지드 언어로 나눠진다.
>
>매니지드 언어는 자바스크립트이고
>
>언매니지드 언어는 대표적으로 C가 있다.





### 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, '_' , '$' 를 쓸 수있다.
- 식별자는 앞글자로 숫자를 쓰지 않는다.
- 변수 선언을 ',' 를 통해서 한꺼번에 가능한데 ','쓰지말자
- 변수 이름은 한국어,일본어 유니코드 허용되는데 영어쓰자
- 대소문자를 구별한다.
- 가독성 높은 문자를 쓰자



네이밍 컨벤션

```js
var firstName // 카멜케이스 : 변수, 함수 이름

var first_name// 스네이크케이스

var FirstName// 파스칼케이스 : 생성자함수, 클래스 이름
```

